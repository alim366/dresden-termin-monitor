name: Dresden Termin Monitor (Telegram)

on:
  schedule:
    - cron: "*/5 * * * *"   # every 5 minutes (UTC)
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest
    env:
      TZ: Europe/Berlin
      TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Heartbeat so you can see each run happened
      - name: Heartbeat
        run: |
          echo "HEARTBEAT: $(date -u '+%Y-%m-%d %H:%M:%S') UTC"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      # Create package.json (ES modules) and install Playwright
      - name: Create package.json
        run: |
          cat > package.json << 'EOF'
          {
            "name": "dresden-termin-monitor",
            "version": "1.0.0",
            "private": true,
            "type": "module",
            "scripts": { "check": "node check.js" },
            "dependencies": { "playwright": "^1.48.2" }
          }
          EOF

      - name: Install dependencies & browser
        run: |
          npm install --no-audit --no-fund
          npx playwright install --with-deps chromium

      # Write the checker script (Telegram only notifies on success)
      - name: Write checker script
        run: |
          cat > check.js << 'EOF'
          import { chromium } from "playwright";

          // --- Config ---
          const URL = "https://termine-buergerbuero.dresden.de/select2?md=1";
          // Wording can vary; adjust if the city changes the label:
          const SERVICE_TEXTS = [
            "Antragsabgabe Einbürgerung",
            "Einbürgerung",
            "Staatsangehörigkeit"
          ];
          const WINDOW = { startHour: 6, endHour: 19 }; // Berlin local hours for activity

          const NO_PATTERNS = [
            /keine\s+freien\s+Termine/i,
            /Zur\s*Zeit.*keine\s+Termine/i,
            /Aktuell\s+sind\s+keine\s+Termine/i,
            /Es\s+sind\s+keine\s+Termine/i,
            /Derzeit\s+stehen\s+keine\s+Termine/i
          ];

          function withinWindow() {
            const fmt = new Intl.DateTimeFormat("de-DE", { timeZone: "Europe/Berlin", hour: "2-digit", hour12: false });
            const h = parseInt(fmt.format(new Date()), 10);
            return h >= WINDOW.startHour && h < WINDOW.endHour;
          }

          async function notifyTelegram(title, message) {
            const token = process.env.TELEGRAM_TOKEN;
            const chatId = process.env.TELEGRAM_CHAT_ID;
            if (!token || !chatId) { console.log("TELEGRAM_SECRETS_MISSING"); return; }
            const text = `*${title}*\n${message}\n[Open booking page](${URL})`;
            const res = await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ chat_id: chatId, text, parse_mode: "Markdown" })
            });
            console.log("TELEGRAM_STATUS", res.status);
          }

          const uniq = (arr) => [...new Set(arr)];

          // Very tolerant extractor: pulls date + up to 3 times if present
          function extractSlots(text) {
            const dateRegex1 = /(\d{2}\.\d{2}\.\d{4})/; // 03.11.2025
            const dateRegex2 = /(?:Mo|Di|Mi|Do|Fr|Sa|So)[.,]?\s+(\d{2}\.\d{2}\.\d{4})/i;
            const timeRegex = /\b([01]?\d|2[0-3]):([0-5]\d)\b/g;

            const dateMatch = text.match(dateRegex1) || text.match(dateRegex2);
            const timesRaw = text.match(timeRegex) || [];
            const times = uniq(timesRaw.map(t => t.trim()));

            // Try to find a location-ish string (best-effort; may be null)
            const locMatch = text.match(/Standort[:\s]*([A-Za-zÄÖÜäöüß\-\s\/]+)</i);
            const location = locMatch ? locMatch[1].trim() : null;

            return { date: dateMatch ? (dateMatch[1] || dateMatch[0]) : null, times, location };
          }

          (async () => {
            try {
              if (!withinWindow()) { console.log("OUTSIDE_WINDOW_SKIP"); process.exit(0); }

              const browser = await chromium.launch({ headless: true });
              const ctx = await browser.newContext({ locale: "de-DE", timezoneId: "Europe/Berlin" });
              const page = await ctx.newPage();

              await page.goto(URL, { waitUntil: "domcontentloaded", timeout: 60000 });

              // Optional: accept cookies if visible
              for (const label of ["OK", "Akzeptieren", "Einverstanden"]) {
                try {
                  const btn = page.getByRole("button", { name: label }).first();
                  if ((await btn.count()) > 0) { await btn.click(); break; }
                  const txt = page.getByText(label, { exact: true });
                  if ((await txt.count()) > 0) { await txt.click(); break; }
                } catch {}
              }

              // Select the service (try several label variants)
              try {
                let clicked = false;
                for (const s of SERVICE_TEXTS) {
                  const service = page.getByText(s, { exact: false }).first();
                  if ((await service.count()) > 0) { await service.click({ force: true }); clicked = true; break; }
                  const label = page.locator(`label:has-text("${s}")`);
                  if ((await label.count()) > 0) { await label.click({ force: true }); clicked = true; break; }
                }
                // If nothing clickable was found, continue anyway—some portals auto-select a default.
              } catch {}

              // Click "Weiter" if present to reach the calendar/suggestions
              try {
                const weiter = page.getByRole("button", { name: /weiter/i }).first();
                if ((await weiter.count()) > 0) {
                  await weiter.click({ force: true });
                } else {
                  await page.locator("text=Weiter").first().click({ timeout: 5000 }).catch(()=>{});
                }
              } catch {}

              // Give the page a moment to render results
              await page.waitForTimeout(2500);

              // Read text of the page (covers most TEVIS templates)
              const bodyText = await page.locator("body").innerText();

              // If it explicitly says "no appointments", do nothing
              if (NO_PATTERNS.some(rx => rx.test(bodyText))) {
                console.log("NO_SLOTS");
                await browser.close();
                process.exit(0);
              }

              // Otherwise try to extract times from combined HTML + text
              const html = await page.content();
              const { date, times, location } = extractSlots(html + "\n" + bodyText);

              if (times.length > 0) {
                const top3 = times.slice(0, 3).join(", ");
                const parts = [];
                if (date) parts.push(`Date: ${date}`);
                parts.push(`Times: ${top3}`);
                if (location) parts.push(`Place: ${location}`);
                const msg = parts.join(" | ");
                await notifyTelegram("Einbürgerung Dresden – Slot available", msg);
                console.log("SLOT_FOUND", msg);
              } else {
                console.log("NO_SLOTS");
              }

              await browser.close();
              process.exit(0);
            } catch (e) {
              // Don’t alert on errors; just log to Action and exit OK (so cron continues)
              console.log("CHECK_FAILED:", e?.message || String(e));
              process.exit(0);
            }
          })();
          EOF

      - name: Run checker
        run: npm run check
